import os
import json
import re
import asyncio
import uuid
from time import monotonic
from collections import Counter
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime, timezone
from pathlib import Path

from fastapi import FastAPI, HTTPException, Query, Response, Request, UploadFile, File
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.gzip import GZipMiddleware
try:
    from starlette.middleware.proxy_headers import ProxyHeadersMiddleware
    _PROXY_HEADERS_AVAILABLE = True
except Exception:
    ProxyHeadersMiddleware = None  # type: ignore
    _PROXY_HEADERS_AVAILABLE = False

from pydantic import BaseModel, Field, ValidationError
from dotenv import load_dotenv
from openai import AsyncOpenAI

# ORJSON (szybsza serializacja) ‚Äì fallback do JSONResponse, je≈õli brak
try:
    from fastapi.responses import ORJSONResponse
    _ORJSON = True
except Exception:
    ORJSONResponse = JSONResponse  # fallback
    _ORJSON = False


# ======================================================================================
# KONFIGURACJA
# ======================================================================================
load_dotenv()

APP_TITLE = "APO Gateway"
APP_DESC = "Gateway + mini-RAG dla prawa o≈õwiatowego"

app = FastAPI(
    title=APP_TITLE,
    description=APP_DESC,
    default_response_class=ORJSONResponse if _ORJSON else JSONResponse,
)

# ENV / domy≈õlne
LLM_DEFAULT_MODEL = os.getenv("LLM_DEFAULT_MODEL", "openai/gpt-4o")
LLM_PLANNER_MODEL = os.getenv("LLM_PLANNER_MODEL", "mistralai/mistral-7b-instruct:free")
KNOWLEDGE_INDEX_PATH = os.getenv("KNOWLEDGE_INDEX_PATH", "index.json")
MAX_RETURN_SNIPPETS = int(os.getenv("MAX_RETURN_SNIPPETS", "5"))
MAX_QUERY_CHARS = int(os.getenv("MAX_QUERY_CHARS", "2000"))
MAX_UPLOAD_BYTES = int(os.getenv("MAX_UPLOAD_BYTES", "2097152"))  # 2 MB
ALLOW_UPLOADS = os.getenv("ALLOW_UPLOADS", "false").lower() == "true"
RATE_LIMIT_ENABLED = os.getenv("RATE_LIMIT_ENABLED", "true").lower() == "true"
RATE_LIMIT_RPM = int(os.getenv("RATE_LIMIT_RPM", "120"))
LEGAL_STATUS_DEFAULT_DATE = os.getenv("LEGAL_STATUS_DEFAULT_DATE", "1 wrze≈õnia 2025 r.")
BULLETIN_PATH = os.getenv("BULLETIN_PATH", "/var/apo/bulletin.json")
ADMIN_KEY = os.getenv("APO_ADMIN_KEY")

# CORS + kompresja
CORS_ORIGINS = [o.strip() for o in os.getenv("CORS_ORIGINS", "").split(",") if o.strip()]
ALLOW_ORIGINS = CORS_ORIGINS if CORS_ORIGINS else ["*"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOW_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "OPTIONS"],
    allow_headers=["content-type", "authorization", "x-request-id"],
)
app.add_middleware(GZipMiddleware, minimum_size=500)
if _PROXY_HEADERS_AVAILABLE:
    app.add_middleware(ProxyHeadersMiddleware, trusted_hosts="*")

# Rate-limit per IP (in-memory; dla 1 procesu)
_RATE_LOG: Dict[str, List[float]] = {}

_client: Optional[AsyncOpenAI] = None
def get_client() -> AsyncOpenAI:
    """Tw√≥rz klienta dopiero przy pierwszym u≈ºyciu; brak klucza = 503 przy wywo≈Çaniu."""
    global _client
    if _client is None:
        key = os.getenv("OPENROUTER_API_KEY")
        if not key:
            raise HTTPException(status_code=503, detail="Brak OPENROUTER_API_KEY w ≈õrodowisku")
        _client = AsyncOpenAI(base_url="https://openrouter.ai/api/v1", api_key=key)
    return _client

def _make_request_id() -> str:
    return str(uuid.uuid4())

# Middleware: X-Request-Id + rate-limit
@app.middleware("http")
async def request_context(request: Request, call_next):
    rid = request.headers.get("X-Request-Id") or _make_request_id()
    if RATE_LIMIT_ENABLED:
        ip = request.client.host if request.client else "unknown"
        now = monotonic()
        bucket = _RATE_LOG.setdefault(ip, [])
        cutoff = now - 60
        while bucket and bucket[0] < cutoff:
            bucket.pop(0)
        # bia≈Ça lista
        if len(bucket) >= RATE_LIMIT_RPM and request.url.path not in ("/health", "/ready", "/live", "/"):
            return ORJSONResponse(
                {"detail": "Rate limit exceeded. Try again later."},
                status_code=429,
                headers={"Retry-After": "30", "X-Request-Id": rid},
            )
        bucket.append(now)
    resp = await call_next(request)
    resp.headers["X-Request-Id"] = rid
    return resp

# Bezpieczne nag≈Ç√≥wki
@app.middleware("http")
async def security_headers(request: Request, call_next):
    resp = await call_next(request)
    resp.headers.setdefault("X-Content-Type-Options", "nosniff")
    resp.headers.setdefault("X-Frame-Options", "DENY")
    resp.headers.setdefault("Referrer-Policy", "no-referrer")
    return resp

# Handlery wyjƒÖtk√≥w
@app.exception_handler(HTTPException)
async def http_exc_handler(request: Request, exc: HTTPException):
    rid = request.headers.get("X-Request-Id") or _make_request_id()
    return ORJSONResponse({"detail": exc.detail}, status_code=exc.status_code, headers={"X-Request-Id": rid})

@app.exception_handler(Exception)
async def unhandled_exc_handler(request: Request, exc: Exception):
    rid = request.headers.get("X-Request-Id") or _make_request_id()
    return ORJSONResponse({"detail": "Internal server error"}, status_code=500, headers={"X-Request-Id": rid})


# ======================================================================================
# PROMPTY
# ======================================================================================
PROMPT_KATEGORYZACJA = (
    "Your only task is to assess if the following query is exclusively about Polish educational law. "
    "Your domain includes: Teacher's Charter, school management, student rights, pedagogical supervision. "
    "Topics like general civil law, copyright law, construction law, or public procurement law are OUTSIDE YOUR DOMAIN. "
    "Answer only 'TAK' or 'NIE'.\nQuery: \"{query}\""
)

PROMPT_ANALIZA_ZAPYTANIA = (
    "Your task is to decompose the user's query into a simple action plan in JSON format. "
    "Analyze the query and return a JSON with a list of tasks under the key 'zadania'. "
    "Allowed tasks are: 'analiza_prawna', 'weryfikacja_cytatu', 'biuletyn_informacyjny'. "
    "Respond ONLY with valid JSON, no explanations.\n\nQuery: \"{query}\""
)

# 9-sekcyjny format + nieujawnianie wewnƒôtrznej KB + wiƒôksze odstƒôpy
PROMPT_SYNTEZA_ODPOWIEDZI = (
    "You are Asystent Prawa O≈õwiatowego. Assemble the verified components into a single, "
    "coherent, professional, and crystal-clear answer in Polish for school leaders. "
    "Use exactly nine sections shown below, in order. Keep it concise and practical. "
    "Never include meta-notes or code blocks; do not reveal internal IDs.\n\n"
    "SEKCJE (W TEJ KOLEJNO≈öCI):\n"
    "1) **Weryfikacja pytania** ‚Äì jedno zdanie parafrazy pytania u≈ºytkownika.\n"
    "2) **Komunikat weryfikacji** ‚Äì linia zaczynajƒÖca siƒô od ‚úÖ i kr√≥tkie potwierdzenie ZAKRESU pytania (neutralne; NIE podawaj jeszcze rozstrzygniƒôcia!).\n"
    "3) **Podstawa prawna ‚öñÔ∏è** ‚Äì lista punktowana artyku≈Ç√≥w/akt√≥w; zako≈Ñcz wierszem:\n"
    "   Stan prawny: [data] (je≈õli brak danych w komponentach, wpisz: {stan_prawny_domyslny} (domy≈õlny)).\n"
    "4) **Interpretacja prawna üí°** ‚Äì 2‚Äì3 kr√≥tkie akapity wyja≈õniajƒÖce sens i wyjƒÖtki.\n"
    "5) **Procedura krok po kroku üìù** ‚Äì lista numerowana 1‚Äì5 (max 7), praktyczne kroki.\n"
    "6) **Odpowied≈∫ wprost üéØ** ‚Äì JEDNO zdanie wyt≈Çuszczone: Tak/Nie + warunek.\n"
    "7) **Proaktywna sugestia üí°** ‚Äì 2‚Äì3 kr√≥tkie wskaz√≥wki.\n"
    "8) **Disclaimer prawny ‚öñÔ∏è** ‚Äì standard: odpowied≈∫ og√≥lna; podaj stan prawny.\n"
    "9) **Dodatkowa oferta wsparcia ü§ù** ‚Äì pytanie otwierajƒÖce.\n\n"
    "FORMATOWANIE (OBOWIƒÑZKOWE):\n"
    "- Przed KA≈ªDƒÑ sekcjƒÖ wstaw poziomƒÖ liniƒô: ---\n"
    "- Po tre≈õci ka≈ºdej sekcji zostaw DWA puste wiersze (dla czytelno≈õci).\n"
    "- Nie u≈ºywaj nag≈Ç√≥wk√≥w #/##/###; sekcje pisz jako wyt≈Çuszczone tytu≈Çy (**) + tekst pod spodem.\n"
    "- W **Podstawa prawna ‚öñÔ∏è** u≈ºyj punktor√≥w (‚Äì) z pe≈Çnymi nazwami akt√≥w i artyku≈Ç√≥w.\n"
    "- W **Odpowied≈∫ wprost üéØ**: ca≈Çe zdanie wyt≈Çuszczone i w osobnym akapicie.\n"
    "- Na ko≈Ñcu dodaj blok **≈πr√≥d≈Ça** oddzielony poziomƒÖ liniƒÖ i wypisz wy≈ÇƒÖcznie publiczne akty/dokumenty "
    "(ISAP, Dz.U., MEN, komunikaty urzƒôdowe). Nigdy nie ujawniaj tytu≈Ç√≥w ani kompozycji wewnƒôtrznej bazy wiedzy.\n\n"
    "== KOMPONENTY ==\n"
    "[Analiza prawna]\n{analiza_prawna}\n\n"
    "[Wynik weryfikacji cytatu]\n{wynik_weryfikacji}\n\n"
    "[Biuletyn informacji ‚Äì najnowsze zmiany]\n{biuletyn_informacyjny}\n\n"
    "ZASADY:\n"
    "- Je≈õli brak kt√≥rego≈õ komponentu, wpisz (brak danych) ‚Äì nie wymy≈õlaj tre≈õci.\n"
    "- Pisz kr√≥tko, jasno, zorientowanie na dyrektor√≥w szk√≥≈Ç.\n"
)

# ======================================================================================
# MODELE
# ======================================================================================
class QueryRequest(BaseModel):
    query: str = Field(..., min_length=3, max_length=MAX_QUERY_CHARS)

class PlanZadania(BaseModel):
    zadania: List[str]

class SynthesisRequest(BaseModel):
    analiza_prawna: Optional[str] = None
    wynik_weryfikacji: Optional[str] = None
    biuletyn_informacyjny: Optional[str] = None

class SearchHit(BaseModel):
    id: str
    title: str
    book: Optional[str] = None
    chapter: Optional[str] = None
    score: float
    snippet: str


# ======================================================================================
# MINI-RAG (opcjonalnie BM25)
# ======================================================================================
IndexEntry = Dict[str, Any]
_INDEX_METADATA: Dict[str, Any] = {}
_ENTRIES: List[IndexEntry] = []
_BM25 = None

try:
    from rank_bm25 import BM25Okapi  # type: ignore
    _BM25_AVAILABLE = True
except Exception:
    _BM25_AVAILABLE = False

def _normalize_text(t: str) -> str:
    return re.sub(r"\s+", " ", t.lower()).strip()

def _tokenize(t: str) -> List[str]:
    t = _normalize_text(t)
    t = re.sub(r"[^\wƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º\s]", " ", t)
    return [tok for tok in t.split() if len(tok) > 2]

def _validate_index_payload(data: Dict[str, Any]) -> None:
    if "entries" not in data or not isinstance(data["entries"], list):
        raise ValueError("Brak pola 'entries' (lista).")
    for i, e in enumerate(data["entries"]):
        if not isinstance(e, dict):
            raise ValueError(f"entries[{i}] nie jest obiektem")
        for key in ("id", "title", "summary"):
            if key not in e or not isinstance(e[key], str) or not e[key].strip():
                raise ValueError(f"entries[{i}].{key} musi byƒá niepustym stringiem")

def _build_bm25():
    global _BM25
    if _BM25_AVAILABLE and _ENTRIES:
        corpus = [e.get("_tokens", []) for e in _ENTRIES]
        _BM25 = BM25Okapi(corpus)

def _load_index(path: str) -> None:
    """≈Åaduj KB; je≈õli brak pliku ‚Äì startuj na pustym (serwis wstaje)."""
    global _INDEX_METADATA, _ENTRIES
    if not os.path.exists(path):
        _INDEX_METADATA = {"version": "empty"}
        _ENTRIES = []
        _build_bm25()
        return
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    if isinstance(data, dict):
        _validate_index_payload(data)
    _INDEX_METADATA = data.get("metadata", {})
    _ENTRIES = data.get("entries", [])
    for e in _ENTRIES:
        e["_title_norm"] = _normalize_text(e.get("title", ""))
        e["_summary_norm"] = _normalize_text(e.get("summary", ""))
        e["_tokens"] = _tokenize(e.get("title", "") + " " + e.get("summary", ""))
    _build_bm25()

_load_index(KNOWLEDGE_INDEX_PATH)

def _score_entry_tf(query_tokens: List[str], entry: IndexEntry) -> float:
    if not query_tokens:
        return 0.0
    cnt = Counter(entry.get("_tokens", []))
    score = sum(cnt[tok] for tok in query_tokens)
    title = entry.get("_title_norm", "")
    q_join = " ".join(query_tokens)
    if q_join and q_join in title:
        score += 2.0
    return float(score)

def search_entries(query: str, k: int = 5) -> List[SearchHit]:
    q_tokens = _tokenize(query)
    hits: List[SearchHit] = []

    if _BM25_AVAILABLE and _BM25 is not None:
        scores = _BM25.get_scores(q_tokens)
        ranked_pairs: List[Tuple[float, IndexEntry]] = list(zip(map(float, scores), _ENTRIES))
        ranked = sorted(ranked_pairs, key=lambda x: x[0], reverse=True)[:k]
    else:
        scored: List[Tuple[float, IndexEntry]] = []
        for e in _ENTRIES:
            s = _score_entry_tf(q_tokens, e)
            if s > 0:
                scored.append((s, e))
        ranked = sorted(scored, key=lambda x: x[0], reverse=True)[:k]

    for s, e in ranked:
        snippet = e.get("summary", "")
        snippet = snippet[:600] + ("‚Ä¶" if len(snippet) > 600 else "")
        hits.append(
            SearchHit(
                id=e.get("id", ""),
                title=e.get("title", ""),
                book=e.get("book"),
                chapter=e.get("chapter"),
                score=float(s),
                snippet=snippet,
            )
        )
    return hits


# ======================================================================================
# LLM (z retry)
# ======================================================================================
async def llm_call(prompt: str, model: str = LLM_DEFAULT_MODEL, timeout: float = 30.0) -> str:
    async def _once() -> str:
        client = get_client()
        resp = await client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
        )
        return resp.choices[0].message.content

    for i in range(2):  # 1 retry
        try:
            return await asyncio.wait_for(_once(), timeout=timeout)
        except asyncio.TimeoutError:
            if i == 1:
                raise HTTPException(status_code=504, detail="Timeout podczas wywo≈Çania modelu AI")
        except Exception as e:
            if i == 1:
                msg = str(e)
                if "429" in msg:
                    raise HTTPException(status_code=429, detail="OpenAI rate limit")
                if "503" in msg or "overloaded" in msg.lower():
                    raise HTTPException(status_code=503, detail="OpenAI service unavailable")
                raise HTTPException(status_code=502, detail=f"B≈ÇƒÖd wywo≈Çania modelu AI: {e}")
            await asyncio.sleep(0.5)

def sanitize_component(text: Optional[str]) -> str:
    if not text:
        return ""
    text = re.sub(r"```.*?```", " ", text, flags=re.S)
    text = re.sub(r"(^|\n)\s*#{1,6}.*", " ", text)
    text = text.replace("<|system|>", "").replace("<|assistant|>", "").replace("<|user|>", "")
    text = text.replace("\u2028", " ").replace("\u2029", " ")
    return text.strip()

def _all_components_empty(req: "SynthesisRequest") -> bool:
    def _empty(x: Optional[str]) -> bool:
        return (x is None) or (isinstance(x, str) and len(x.strip()) == 0)
    return _empty(req.analiza_prawna) and _empty(req.wynik_weryfikacji) and _empty(req.biuletyn_informacyjny)


# ======================================================================================
# Polityka: nie ujawniamy sk≈Çadu KB (wykrywanie metapytania)
# ======================================================================================
_KB_META_PATTERNS = [
    r"\bbaza wiedzy\b",
    r"\bspis tre≈õci\b", r"\bspis tresci\b",
    r"\bjakich ≈∫r√≥de≈Ç\b", r"\bjakich zrodel\b",
    r"\bjakie ≈∫r√≥d≈Ça\b", r"\bjakie zrodla\b",
    r"\bz jakich dokument√≥w\b", r"\bz jakich dokumentow\b",
    r"\bjakie dokumenty masz\b", r"\bco masz w bazie\b",
    r"\bpoka≈º bazƒô\b", r"\bpokaz baze\b",
    r"\blista ≈∫r√≥de≈Ç\b", r"\blista zrodel\b",
]
def _is_kb_meta_query(text: str) -> bool:
    t = text.lower().strip()
    for pat in _KB_META_PATTERNS:
        if re.search(pat, t):
            return True
    return False


# ======================================================================================
# BIULETYN: wczytywanie lokalnego feedu i endpoint do CRON-a
# ======================================================================================
def _load_bulletin_text() -> str:
    p = Path(BULLETIN_PATH)
    if not p.exists():
        return ""
    try:
        data = json.loads(p.read_text(encoding="utf-8"))
        items = data.get("items", [])
        if not items:
            return ""
        off = [i for i in items if i.get("source_type") == "official"]
        unoff = [i for i in items if i.get("source_type") == "unofficial"]

        lines: List[str] = []
        if off:
            lines.append("**Biuletyn (≈∫r√≥d≈Ça oficjalne)**")
            for it in off[:5]:
                lines.append(f"- {it.get('title')} ‚Äî {it.get('source')} ({it.get('date')})")
            lines.append("")

        if unoff:
            lines.append("**Dodatkowe komentarze (≈∫r√≥d≈Ça nieoficjalne)**")
            for it in unoff[:3]:
                lines.append(f"- {it.get('title')} ‚Äî {it.get('source')} ({it.get('date')})")
            lines.append("_Uwaga: pozycje z nieoficjalnych ≈∫r√≥de≈Ç majƒÖ charakter informacyjny._")

        return "\n".join(lines).strip()
    except Exception:
        return ""

# Import aktualizatora ≈∫r√≥de≈Ç (osobny plik public_sources.py)
try:
    from public_sources import refresh_all as refresh_all_sources  # zgodnie z Twoim modu≈Çem
except Exception:
    refresh_all_sources = None  # brak ‚Äì endpoint zwr√≥ci 501


# ======================================================================================
# POMOCNICZE: gotowe wiadomo≈õci w 9-sekcyjnym formacie
# ======================================================================================
def _md_block_separator() -> str:
    return "---\n"

def _two_blank_lines() -> str:
    return "\n\n"

def _refusal_markdown() -> str:
    """Ujednolicona odmowa (poza domenƒÖ) w tym samym uk≈Çadzie 9 sekcji."""
    parts = []
    parts.append(_md_block_separator() + "**Weryfikacja pytania**\nTo pytanie nie dotyczy polskiego prawa o≈õwiatowego.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Komunikat weryfikacji**\n‚úÖ Pytanie wykracza poza zakres Asystenta Prawa O≈õwiatowego (prawo o≈õwiatowe).")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Podstawa prawna ‚öñÔ∏è**\n‚Äì (brak danych)\nStan prawny: " + LEGAL_STATUS_DEFAULT_DATE + " (domy≈õlny).")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Interpretacja prawna üí°**\nAsystent Prawa O≈õwiatowego udziela informacji wy≈ÇƒÖcznie w obszarze prawa o≈õwiatowego (Karta Nauczyciela, Prawo o≈õwiatowe, akty MEN). Pytania z zakresu podatk√≥w, ubezpiecze≈Ñ, prawa cywilnego czy gospodarczego nie sƒÖ obs≈Çugiwane.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Procedura krok po kroku üìù**\n1. Sformu≈Çuj pytanie dotyczƒÖce prawa o≈õwiatowego.\n2. Je≈õli chodzi o innƒÖ dziedzinƒô (np. VAT), skonsultuj siƒô ze specjalistƒÖ w danej dziedzinie.\n3. Podaj kontekst (typ szko≈Çy, etap edukacyjny), aby uzyskaƒá precyzyjniejszƒÖ odpowied≈∫.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Odpowied≈∫ wprost üéØ**\n**Nie ‚Äì nie odpowiadam na pytania spoza domeny prawa o≈õwiatowego.**")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Proaktywna sugestia üí°**\nRozwa≈º zadanie pytania dotyczƒÖcego Karty Nauczyciela, obowiƒÖzk√≥w dyrektora, organizacji pracy szko≈Çy lub uprawnie≈Ñ uczni√≥w.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Disclaimer prawny ‚öñÔ∏è**\nOdpowied≈∫ ma charakter og√≥lny i dotyczy wy≈ÇƒÖcznie prawa o≈õwiatowego. Stan prawny: " + LEGAL_STATUS_DEFAULT_DATE + ".")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Dodatkowa oferta wsparcia ü§ù**\nCzy chcesz, abym pom√≥g≈Ç przeformu≈Çowaƒá pytanie tak, aby dotyczy≈Ço prawa o≈õwiatowego?")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**≈πr√≥d≈Ça**\n‚Äì (brak ‚Äì pytanie spoza domeny)")
    return "".join(parts)

def _kb_scope_markdown() -> str:
    """Ujednolicona odpowied≈∫ na meta-pytanie o bazƒô (zakres, bez ujawniania sk≈Çadu)."""
    parts = []
    parts.append(_md_block_separator() + "**Weryfikacja pytania**\nPro≈õba o przedstawienie bazy wiedzy i ≈∫r√≥de≈Ç.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Komunikat weryfikacji**\n‚úÖ Pytanie dotyczy zakresu tematycznego i rodzaju ≈∫r√≥de≈Ç wykorzystywanych przez APO.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Podstawa prawna ‚öñÔ∏è**\n‚Äì Karta Nauczyciela (ustawa z 26 stycznia 1982 r.)\n‚Äì Prawo o≈õwiatowe (ustawa z 14 grudnia 2016 r.)\n‚Äì Wybrane rozporzƒÖdzenia MEN\n‚Äì Orzecznictwo oraz oficjalne komunikaty organ√≥w administracji\nStan prawny: " + LEGAL_STATUS_DEFAULT_DATE + " (domy≈õlny).")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Interpretacja prawna üí°**\nAPO udziela odpowiedzi wy≈ÇƒÖcznie w obszarze polskiego prawa o≈õwiatowego. W odpowiedziach cytowane sƒÖ wy≈ÇƒÖcznie publicznie dostƒôpne akty i dokumenty. Sk≈Çad wewnƒôtrznych materia≈Ç√≥w pomocniczych nie jest ujawniany.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Procedura krok po kroku üìù**\n1. Podaj konkretne zagadnienie (np. artyku≈Ç KN, statut szko≈Çy, arkusz).\n2. Otrzymasz analizƒô wraz z podstawƒÖ prawnƒÖ i kr√≥tkƒÖ procedurƒÖ.\n3. W razie potrzeby doprecyzuj kontekst (typ szko≈Çy, etap, rola pytajƒÖcego).")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Odpowied≈∫ wprost üéØ**\n**APO przedstawia jedynie og√≥lny zakres ≈∫r√≥de≈Ç (akty publiczne) i nie ujawnia sk≈Çadu wewnƒôtrznej bazy wiedzy.**")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Proaktywna sugestia üí°**\nPodaj proszƒô konkretne pytanie z obszaru prawa o≈õwiatowego; przygotujƒô zwiƒôz≈ÇƒÖ analizƒô z podstawƒÖ prawnƒÖ.")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Disclaimer prawny ‚öñÔ∏è**\nOdpowied≈∫ ma charakter og√≥lny i dotyczy zakresu tematycznego. Stan prawny: " + LEGAL_STATUS_DEFAULT_DATE + ".")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**Dodatkowa oferta wsparcia ü§ù**\nCzy chcesz, abym zaproponowa≈Ç katalog przyk≈Çadowych temat√≥w (dyrektor, rada pedagogiczna, KN, statut)?")
    parts.append(_two_blank_lines())
    parts.append(_md_block_separator() + "**≈πr√≥d≈Ça**\n‚Äì ISAP (akty prawne)\n‚Äì Dziennik Ustaw / RCL\n‚Äì MEN ‚Äì komunikaty i rozporzƒÖdzenia")
    return "".join(parts)


# ======================================================================================
# ENDPOINTY
# ======================================================================================
@app.get("/")
def root():
    return {
        "name": "APO Gateway",
        "status": "ok",
        "docs": "/docs",
        "redoc": "/redoc",
        "health": "/health",
        "ready": "/ready",
        "live": "/live"
    }

@app.get("/live")
def liveness() -> Dict[str, Any]:
    return {"status": "alive"}

@app.get("/ready")
def readiness() -> Dict[str, Any]:
    kb_ok = len(_ENTRIES) > 0
    has_key = bool(os.getenv("OPENROUTER_API_KEY"))
    disk_ok = True
    try:
        Path(BULLETIN_PATH).parent.mkdir(parents=True, exist_ok=True)
    except Exception:
        disk_ok = False
    return {"ready": kb_ok and has_key and disk_ok, "kb_loaded": kb_ok, "has_api_key": has_key, "disk_ok": disk_ok}

@app.get("/health")
def health_check() -> Dict[str, Any]:
    return {
        "status": "ok",
        "entries": len(_ENTRIES),
        "kb_version": _INDEX_METADATA.get("version"),
        "model_default": LLM_DEFAULT_MODEL,
        "model_planner": LLM_PLANNER_MODEL,
        "has_api_key": bool(os.getenv("OPENROUTER_API_KEY")),
        "bm25": bool(_BM25_AVAILABLE and _BM25 is not None),
        "rate_limit_rpm": RATE_LIMIT_RPM if RATE_LIMIT_ENABLED else 0,
        "orjson": _ORJSON,
        "bulletin_exists": Path(BULLETIN_PATH).exists()
    }

@app.post("/analyze-query")
async def analyze_query(request: QueryRequest) -> Dict[str, Any]:
    q = (request.query or "").strip()
    if not q:
        raise HTTPException(status_code=422, detail="Puste zapytanie.")
    if len(q) > MAX_QUERY_CHARS:
        raise HTTPException(status_code=413, detail=f"Zapytanie zbyt d≈Çugie (>{MAX_QUERY_CHARS} znak√≥w).")

    # Meta-pytania o bazƒô: nie ujawniamy sk≈Çadu; zwracamy tylko zakres
    if _is_kb_meta_query(q):
        return {"zadania": ["META_KB_SCOPE_ONLY"]}

    # Kategoryzacja domeny
    k_prompt = PROMPT_KATEGORYZACJA.format(query=q)
    k_raw = (await llm_call(k_prompt, model=LLM_PLANNER_MODEL)).strip().upper()
    k_value = "TAK" if k_raw == "TAK" else ("NIE" if k_raw == "NIE" else "TAK")
    if k_value == "NIE":
        return {"zadania": ["ODRZUCONE_SPOZA_DOMENY"]}

    # Plan zada≈Ñ (JSON)
    p_prompt = PROMPT_ANALIZA_ZAPYTANIA.format(query=q)
    p_raw = await llm_call(p_prompt, model=LLM_PLANNER_MODEL)
    m = re.search(r"\{[\s\S]*\}", p_raw)
    plan_json = m.group(0) if m else '{"zadania":["analiza_prawna"]}'
    try:
        plan = PlanZadania.model_validate_json(plan_json)
    except ValidationError:
        plan = PlanZadania(zadania=["analiza_prawna"])
    return plan.model_dump()

@app.get("/knowledge/search", response_model=List[SearchHit])
async def knowledge_search(q: str = Query(..., min_length=2), k: int = Query(MAX_RETURN_SNIPPETS, ge=1, le=10)):
    return search_entries(q, k=k)

@app.post("/gate-and-format-response")
async def gate_and_format_response(request: SynthesisRequest):
    # Poza domenƒÖ ‚Üí ujednolicona odmowa w 9 sekcjach (markdown)
    if request.analiza_prawna == "ODRZUCONE_SPOZA_DOMENY":
        return Response(content=_refusal_markdown(), media_type="text/markdown; charset=utf-8")

    # Meta-pytanie o KB ‚Üí ujednolicona odpowied≈∫ w 9 sekcjach (zakres, bez sk≈Çadu)
    if request.analiza_prawna == "META_KB_SCOPE_ONLY":
        return Response(content=_kb_scope_markdown(), media_type="text/markdown; charset=utf-8")

    # Brak tre≈õci
    if _all_components_empty(request):
        raise HTTPException(status_code=400, detail="Brak tre≈õci do zsyntezowania (wszystkie komponenty puste).")

    analiza = sanitize_component(request.analiza_prawna)
    wery = sanitize_component(request.wynik_weryfikacji)
    # Je≈õli brak biuletynu w komponencie ‚Äì domy≈õlnie dociƒÖgnij lokalny bulletin.json (CRON)
    biul = sanitize_component(request.biuletyn_informacyjny) or _load_bulletin_text()

    prompt = PROMPT_SYNTEZA_ODPOWIEDZI.format(
        analiza_prawna=analiza or "(brak danych)",
        wynik_weryfikacji=wery or "(brak danych)",
        biuletyn_informacyjny=biul or "(brak danych)",
        stan_prawny_domyslny=LEGAL_STATUS_DEFAULT_DATE,
    )
    final_md = await llm_call(prompt, model=LLM_DEFAULT_MODEL)
    return Response(content=final_md, media_type="text/markdown; charset=utf-8")

# Admin: reload KB (bez uploadu)
@app.post("/admin/reload-index")
async def admin_reload_index():
    _load_index(KNOWLEDGE_INDEX_PATH)
    return {"ok": True, "entries": len(_ENTRIES)}

# Admin: upload index.json (multipart) ‚Äì je≈õli ALLOW_UPLOADS=true
@app.post("/admin/upload-index")
async def admin_upload_index(file: UploadFile = File(...), request: Request = None):
    if not ALLOW_UPLOADS:
        raise HTTPException(status_code=403, detail="Upload wy≈ÇƒÖczony (ALLOW_UPLOADS=false).")

    if request:
        cl = request.headers.get("content-length")
        if cl and int(cl) > MAX_UPLOAD_BYTES:
            raise HTTPException(status_code=413, detail=f"Plik za du≈ºy (limit {MAX_UPLOAD_BYTES} B)")

    if file.content_type not in ("application/json", "text/json", "application/octet-stream"):
        raise HTTPException(status_code=415, detail="Dozwolone tylko JSON (application/json)")

    if not file.filename.endswith(".json"):
        raise HTTPException(status_code=415, detail="Dozwolone sƒÖ tylko pliki .json")

    try:
        content = await file.read()
        data = json.loads(content.decode("utf-8"))
        _validate_index_payload(data)
        with open(KNOWLEDGE_INDEX_PATH, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        _load_index(KNOWLEDGE_INDEX_PATH)
        return {"ok": True, "entries": len(_ENTRIES)}
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Nieprawid≈Çowy JSON")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Upload nieudany: {e}")

# Admin: CRON ‚Äì od≈õwie≈º biuletyn (ISAP/RCL/MEN + Infor)
@app.post("/admin/refresh-public-sources")
async def refresh_public_sources(request: Request):
    if not ADMIN_KEY or request.headers.get("X-APO-Key") != ADMIN_KEY:
        raise HTTPException(status_code=401, detail="Unauthorized")
    if refresh_all_sources is None:
        raise HTTPException(status_code=501, detail="Brak modu≈Çu public_sources.refresh_all")
    payload = refresh_all_sources()
    Path(BULLETIN_PATH).parent.mkdir(parents=True, exist_ok=True)
    Path(BULLETIN_PATH).write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
    return {"ok": True, "items": len(payload.get("items", [])), "updated": payload.get("updated_at")}

# DEV entrypoint
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=int(os.getenv("PORT", "8000")), reload=True)